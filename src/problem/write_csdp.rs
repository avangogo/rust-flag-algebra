use crate::problem::sdp::ProblemView;
use crate::{Flag, Savable};
use log::{debug, info};
use num::Zero;
use std::fmt::Display;
use std::fs::File;
use std::io;
use std::io::{BufWriter, Write};
use std::ops::Neg;
use std::path::PathBuf;

// Write a line of a sdpa file
fn write_coeff<N>(
    file: &mut BufWriter<File>,
    mat_num: usize,
    block_num: usize,
    i: usize,
    j: usize,
    value: N,
) -> io::Result<()>
where
    N: Display + Zero + PartialEq,
{
    if value != N::zero() {
        writeln!(
            file,
            "{} {} {} {} {}",
            mat_num,
            block_num + 1,
            i + 1,
            j + 1,
            value
        )?;
    }
    Ok(())
}

// Write a coefficient `value` on position (i ,i) for an inequality,
// or `value` and `-value` on positions (2i, 2i), (2i+1, 2i+1) for an equality
fn write_ineq_coeff<N>(
    file: &mut BufWriter<File>,
    mat_num: usize,
    block_num: usize,
    i: usize,
    value: N,
    equality: bool,
) -> io::Result<()>
where
    N: Display + Zero + PartialEq + Neg<Output = N> + Copy,
{
    if equality {
        write_coeff(file, mat_num, block_num, 2 * i, 2 * i, value)?;
        write_coeff(file, mat_num, block_num, 2 * i + 1, 2 * i + 1, -value)?;
    } else {
        write_coeff(file, mat_num, block_num, i, i, value)?;
    }
    Ok(())
}

fn format_count(count: usize, max: usize) -> String {
    if count == max {
        format!("{count}")
    } else {
        format!("{count}/{max}")
    }
}

/// Write a description of the problem as a comment in the .sdpa file
fn write_header<N, F: Flag, W: Write>(view: &ProblemView<'_, N, F>, file: &mut W) -> io::Result<()>
where
    N: Display + Neg<Output = N> + Zero + Copy + PartialEq,
{
    writeln!(file, "* Semi-Definite Problem generated by Rust")?;
    writeln!(file, "*")?;
    writeln!(file, "* Flags: {}", F::NAME)?;
    writeln!(
        file,
        "* Basis: {:} ({} flags)",
        view.obj.basis,
        view.obj.basis.get().len()
    )?;
    writeln!(
        file,
        "* {} groups of linear constraints ({})",
        view.ineqs.len(),
        format_count(
            view.ineqs.iter().map(|i| { i.len() }).sum::<usize>(),
            view.ineqs
                .iter()
                .map(|ineq| { ineq.selected.data.len() })
                .sum::<usize>()
        )
    )?;
    writeln!(
        file,
        "* {} Cauchy-Schwarz constraints",
        format_count(view.cs.len(), view.cs.selected.len())
    )?;
    writeln!(
        file,
        "* {} additional constraints on Cauchy-Schwarz matrices",
        view.cs_subspace.len(),
    )?;
    writeln!(file, "*")?;
    write!(file, "* Minimizing: {}", view.obj.expr)?;
    match view.obj.scale {
        1 => writeln!(file)?,
        s => writeln!(file, " (scale {s})")?,
    }
    writeln!(file, "* Under the constraints:")?;
    for ineqs in view.ineqs.iter() {
        writeln!(
            file,
            "* # {} ({})",
            ineqs.meta(),
            format_count(ineqs.len(), ineqs.selected.data.len())
        )?;
    }
    for cs in view.cs.iter() {
        writeln!(
            file,
            "* # Cauchy-Schwarz: {}x{}; {:?}",
            cs.1.split.left_basis().size,
            cs.1.split.right_basis().size,
            cs.1.split.right_basis().t,
        )?;
    }
    writeln!(file, "*")?;
    Ok(())
}

/// Write the semi-definite program in the file `filename` in the sdpa format.
pub fn write_sdpa<N, F: Flag>(view: &ProblemView<'_, N, F>, filename: &str) -> io::Result<()>
where
    N: Display + Neg<Output = N> + Zero + Copy + PartialEq,
{
    let mut filename = PathBuf::from(filename);
    let _ = filename.set_extension("sdpa");
    info!("Writing problem in {}", filename.display());
    let mut file = BufWriter::new(File::create(&filename)?);
    write_header(view, &mut file)?;
    debug!("Generating Cauchy-Schwarz inequalities");
    let cs_mat: Vec<_> = view.cs.get();
    writeln!(file, "{}", view.obj.data.len() + view.cs_subspace.len())?;
    // Line 2: Number of blocks (one for each constraint)
    writeln!(file, "{}", view.ineqs.len() + view.cs.len())?;
    // Line 3: Sizes of the blocks
    for ineq in view.ineqs.iter() {
        assert!(ineq.len() > 0);
        write!(file, "-{} ", ineq.len_spliting_equalities())?;
    }
    for split in &cs_mat {
        write!(file, "{} ", split[0].rows())?;
    }
    writeln!(file)?;
    // Line 4: vector ai
    // ai is the needed coefficient for the flag Fi
    for v in &view.obj.data {
        write!(file, "{v} ")?;
    }
    for _ in &view.cs_subspace {
        write!(file, "0 ")?;
    }
    write!(file, "\n\n")?;
    // Lines 5+: body
    // Matrix 0: Objective
    for (block_num, ineq) in view.ineqs.iter().enumerate() {
        for (i, ineq_data) in ineq.iter().enumerate() {
            write_ineq_coeff(
                &mut file,
                0,
                block_num,
                i,
                ineq_data.bound,
                ineq.meta().equality,
            )?;
        }
    }
    writeln!(file)?;
    // Matrices 1+:
    // Inequality blocks
    for (block_num, ineq) in view.ineqs.iter().enumerate() {
        for (i, ineq_data) in ineq.iter().enumerate() {
            for (mat_num, &v) in ineq_data.flag.iter() {
                write_ineq_coeff(
                    &mut file,
                    mat_num + 1,
                    block_num,
                    i,
                    v,
                    ineq.meta().equality,
                )?;
            }
        }
    }
    writeln!(file)?;
    // Cs blocks
    let block_offset = view.ineqs.len();
    for (block_num, line) in cs_mat.iter().enumerate() {
        for (mat_num, matrix) in line.iter().enumerate() {
            for (&v, (i, j)) in matrix {
                if i <= j {
                    write_coeff(&mut file, mat_num + 1, block_num + block_offset, i, j, v)?;
                }
            }
        }
    }
    // Cs subspace constraints
    let mat_offset = view.obj.data.len();
    for (i_mat, (block_num, matrix)) in view.cs_subspace.iter().enumerate() {
        for (&v, (i, j)) in *matrix {
            if i <= j {
                let mat_num = mat_offset + i_mat + 1;
                write_coeff(&mut file, mat_num, block_num + block_offset, i, j, v)?;
            }
        }
    }
    Ok(())
}

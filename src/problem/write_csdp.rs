use crate::problem::info::ProblemInfo;
use crate::problem::sdp::ProblemView;
use crate::{Flag, Savable};
use log::{debug, info};
use num::Zero;
use sprs::CsMat;
use std::fmt::Display;
use std::fs::File;
use std::io;
use std::io::{BufWriter, Write};
use std::ops::Neg;
use std::path::PathBuf;

// Write a line of a sdpa file
fn write_coeff<N>(
    file: &mut BufWriter<File>,
    mat_num: usize,
    block_num: usize,
    i: usize,
    j: usize,
    value: N,
) -> io::Result<()>
where
    N: Display + Zero + PartialEq + Copy,
{
    if value != N::zero() {
        writeln!(
            file,
            "{} {} {} {} {}",
            mat_num,
            block_num + 1,
            i + 1,
            j + 1,
            value
        )?;
    }
    Ok(())
}

fn write_matrix<N>(
    file: &mut BufWriter<File>,
    mat_num: usize,
    block_num: usize,
    matrix: &CsMat<N>,
) -> io::Result<()>
where
    N: Display + Zero + PartialEq + Copy,
{
    for (&v, (i, j)) in matrix {
        if i <= j {
            write_coeff(file, mat_num, block_num, i, j, v)?;
        }
    }
    Ok(())
}

// Write a coefficient `value` on position (i ,i) for an inequality,
// or `value` and `-value` on positions (2i, 2i), (2i+1, 2i+1) for an equality
fn write_ineq_coeff<N>(
    file: &mut BufWriter<File>,
    mat_num: usize,
    block_num: usize,
    i: usize,
    value: N,
    equality: bool,
) -> io::Result<()>
where
    N: Display + Zero + PartialEq + Neg<Output = N> + Copy,
{
    if equality {
        write_coeff(file, mat_num, block_num, 2 * i, 2 * i, value)?;
        write_coeff(file, mat_num, block_num, 2 * i + 1, 2 * i + 1, -value)?;
    } else {
        write_coeff(file, mat_num, block_num, i, i, value)?;
    }
    Ok(())
}

fn format_count((count, max): (usize, usize)) -> String {
    if count == max {
        format!("{count}")
    } else {
        format!("{count}/{max}")
    }
}

/// Write a description of the problem
fn get_info<N: Clone, F: Flag>(view: &ProblemView<'_, N, F>) -> ProblemInfo<N, F> {
    ProblemInfo {
        flag_name: F::NAME,
        basis: view.obj.basis,
        n_flags: view.obj.basis.get().len(),
        n_selected_ineqs: (
            view.ineqs.iter().map(|i| i.len()).sum(),
            view.ineqs
                .iter()
                .map(|ineq| ineq.selected.data.len())
                .sum::<usize>(),
        ),
        n_selected_cs: (view.cs.len(), view.cs.selected.len()),
        n_cs_subspace: view.cs_subspace.len(),
        obj_expr: view.obj.expr.clone(),
        obj_scale: view.obj.scale,
        ineq_group_infos: view
            .ineqs
            .iter()
            .map(|ineqs| {
                (
                    (*ineqs.meta()).clone(),
                    (ineqs.len(), ineqs.selected.data.len()),
                )
            })
            .collect(),
        cs: view.cs.iter().map(|cs| cs.operator.split).collect(),
    }
}

/// Write a description of the problem as a comment in the .sdpa file
fn write_header<N, F: Flag, W: Write>(info: &ProblemInfo<N, F>, file: &mut W) -> io::Result<()>
where
    N: Display,
{
    writeln!(file, "* Semi-Definite Problem generated by Rust")?;
    writeln!(file, "*")?;
    writeln!(file, "* Flags: {}", info.flag_name)?;
    writeln!(file, "* Basis: {:} ({} flags)", info.basis, info.n_flags)?;
    writeln!(
        file,
        "* {} groups of linear constraints ({})",
        info.ineq_group_infos.len(),
        format_count(info.n_selected_ineqs)
    )?;
    writeln!(
        file,
        "* {} Cauchy-Schwarz constraints",
        format_count(info.n_selected_cs)
    )?;
    writeln!(
        file,
        "* {} additional constraints on Cauchy-Schwarz matrices",
        info.n_cs_subspace,
    )?;
    writeln!(file, "*")?;
    write!(file, "* Minimizing: {}", info.obj_expr)?;
    match info.obj_scale {
        1 => writeln!(file)?,
        s => writeln!(file, " (scale {s})")?,
    }
    writeln!(file, "* Under the constraints:")?;
    for (ineq_meta, n_selected) in &info.ineq_group_infos {
        writeln!(file, "* # {ineq_meta} ({})", format_count(*n_selected))?;
    }
    for cs in &info.cs {
        writeln!(
            file,
            "* # Cauchy-Schwarz: {}x{}; {:?}",
            cs.left_basis().size,
            cs.right_basis().size,
            cs.right_basis().t,
        )?;
    }
    writeln!(file, "*")?;
    Ok(())
}

/// Write the semi-definite program in the file `filename` in the sdpa format.
pub fn write_sdpa<N, F: Flag>(view: &ProblemView<'_, N, F>, filename: &str) -> io::Result<()>
where
    N: Display + Neg<Output = N> + Zero + Copy + PartialEq,
{
    let mut filename = PathBuf::from(filename);
    let _ = filename.set_extension("sdpa");
    info!("Writing problem in {}", filename.display());
    let mut file = BufWriter::new(File::create(&filename)?);
    let info = get_info(view);
    write_header(&info, &mut file)?;
    debug!("Generating Cauchy-Schwarz inequalities");
    writeln!(file, "{}", view.obj.data.len() + view.cs_subspace.len())?;
    // Line 2: Number of blocks (one for each constraint)
    writeln!(file, "{}", view.ineqs.len() + view.cs.len())?;
    // Line 3: Sizes of the blocks
    for ineq in view.ineqs.iter() {
        assert!(ineq.len() > 0);
        write!(file, "-{} ", ineq.len_spliting_equalities())?;
    }
    let cs_mat: Vec<_> = view.cs.iter().map(|m| m.get()).collect();
    for split in &cs_mat {
        write!(file, "{} ", split[0].rows())?;
    }
    writeln!(file)?;
    // Line 4: vector ai
    // ai is the needed coefficient for the flag Fi
    for v in &view.obj.data {
        write!(file, "{v} ")?;
    }
    for _ in &view.cs_subspace {
        write!(file, "0 ")?;
    }
    write!(file, "\n\n")?;
    // Lines 5+: body
    // Matrix 0: Objective
    for (block_num, ineq) in view.ineqs.iter().enumerate() {
        for (i, ineq_data) in ineq.iter().enumerate() {
            write_ineq_coeff(
                &mut file,
                0,
                block_num,
                i,
                ineq_data.bound,
                ineq.meta().equality,
            )?;
        }
    }
    writeln!(file)?;
    // Matrices 1+:
    // Inequality blocks
    for (block_num, ineq) in view.ineqs.iter().enumerate() {
        for (i, ineq_data) in ineq.iter().enumerate() {
            for (mat_num, &v) in ineq_data.flag.iter() {
                write_ineq_coeff(
                    &mut file,
                    mat_num + 1,
                    block_num,
                    i,
                    v,
                    ineq.meta().equality,
                )?;
            }
        }
    }
    writeln!(file)?;
    // Cs blocks
    let block_offset = view.ineqs.len();
    for (block_num, line) in cs_mat.iter().enumerate() {
        for (mat_num, matrix) in line.iter().enumerate() {
            write_matrix(&mut file, mat_num + 1, block_num + block_offset, matrix)?
        }
    }
    // Cs subspace constraints
    let mat_offset = view.obj.data.len();
    for (i_mat, (block_num, matrix)) in view.cs_subspace.iter().enumerate() {
        let mat_num = mat_offset + i_mat + 1;
        write_matrix(&mut file, mat_num, block_offset + block_num, *matrix)?
    }
    Ok(())
}
